# File Layout Contract

**Document**: StudyScribe Data Storage & File Organization  
**Purpose**: Comprehensive specification of what data lives in SQLite vs filesystem, folder structure, naming conventions, and export mechanics  
**Scope**: Every claim cites implementation from [studyscribe/](studyscribe/) and [studyscribe/services/](studyscribe/services/)

---

## Executive Summary

StudyScribe uses a **hybrid storage model**:
- **SQLite** ([studyscribe/core/db.py](studyscribe/core/db.py#L11-L73)): Module/session metadata, AI chat messages, job status
- **Filesystem** ([studyscribe/core/config.py](studyscribe/core/config.py#L14)): Audio, attachments, transcripts, annotations, AI notes, cached chunks

Data is **deterministically organized** by module/session UUIDs with standard subdirectories. **All user-provided names** (module names, session names) are sanitized for safe filesystem use. **Exports** are ZIP archives assembled on-the-fly from selected components.

---

## Part 1: Data Storage Split

### SQLite Tables and Schema

**Database File**: `studyscribe/studyscribe.db` (via `DB_PATH` in [studyscribe/core/config.py](studyscribe/core/config.py#L15))

**Schema** ([studyscribe/core/db.py](studyscribe/core/db.py#L13-L73)):

```sql
CREATE TABLE modules (
    id TEXT PRIMARY KEY,           -- UUID generated by client
    name TEXT NOT NULL,            -- User-provided, e.g., "Organic Chemistry"
    created_at TEXT NOT NULL       -- ISO 8601 UTC timestamp
);

CREATE TABLE sessions (
    id TEXT PRIMARY KEY,           -- UUID generated by client
    module_id TEXT NOT NULL,       -- FK to modules.id
    name TEXT NOT NULL,            -- User-provided, e.g., "Lecture 1"
    created_at TEXT NOT NULL       -- ISO 8601 UTC timestamp
    FOREIGN KEY(module_id) REFERENCES modules(id)
);

CREATE TABLE jobs (
    id TEXT PRIMARY KEY,           -- UUID for background job
    status TEXT NOT NULL,          -- "queued" | "in_progress" | "success" | "error"
    progress INTEGER NOT NULL,     -- 0-100 percentage
    message TEXT,                  -- Human-readable status update (e.g., "Processing chunk 3/5")
    result_path TEXT,              -- Path to result file (e.g., "session_dir/transcript/transcript.json")
    created_at TEXT NOT NULL,      -- ISO 8601 UTC timestamp
    updated_at TEXT NOT NULL       -- ISO 8601 UTC timestamp
);

CREATE TABLE session_summaries (
    session_id TEXT PRIMARY KEY,   -- FK to sessions.id
    content_hash TEXT NOT NULL,    -- SHA256 hash of combined content for cache invalidation
    summary TEXT NOT NULL,         -- Plain text summary of session (for multi-session Q&A)
    updated_at TEXT NOT NULL       -- ISO 8601 UTC timestamp
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);

CREATE TABLE module_summaries (
    module_id TEXT PRIMARY KEY,    -- FK to modules.id
    content_hash TEXT NOT NULL,    -- SHA256 hash of module content
    summary TEXT NOT NULL,         -- Plain text summary of module (for module-scope Q&A)
    updated_at TEXT NOT NULL       -- ISO 8601 UTC timestamp
    FOREIGN KEY(module_id) REFERENCES modules(id)
);

CREATE TABLE ai_messages (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Auto-incrementing row ID
    session_id TEXT NOT NULL,              -- FK to sessions.id
    role TEXT NOT NULL,                    -- "user" | "assistant"
    content TEXT NOT NULL,                 -- Markdown or plain text
    created_at TEXT NOT NULL               -- ISO 8601 UTC timestamp
    FOREIGN KEY(session_id) REFERENCES sessions(id)
);

CREATE TABLE ai_message_sources (
    id INTEGER PRIMARY KEY AUTOINCREMENT,  -- Auto-incrementing row ID
    message_id INTEGER NOT NULL,           -- FK to ai_messages.id
    source_id TEXT NOT NULL,               -- Unique source ID (UUID or numeric)
    kind TEXT NOT NULL,                    -- "transcript" | "attachment" | "ai_notes" | "session_summary" | etc.
    label TEXT NOT NULL,                   -- Human-readable source label (e.g., "Transcript [00:32–01:15]")
    snippet TEXT,                          -- Excerpt from source (max ~220 chars for preview)
    session_name TEXT,                     -- Name of session containing source
    url TEXT,                              -- URL to open source (e.g., "/modules/.../attachments/slides.pdf#page=3")
    source_json TEXT                       -- Full JSON serialization of source object (added via ALTER TABLE)
    FOREIGN KEY(message_id) REFERENCES ai_messages(id)
);
```

**Initialization**: [studyscribe/core/db.py](studyscribe/core/db.py#L76-L81) via `init_db()` at app startup.

### Filesystem Storage

**Base Directory**: `DATA_DIR = studyscribe/data/` (via [studyscribe/core/config.py](studyscribe/core/config.py#L14))

**What Lives on Disk**:
- Audio files (uploads)
- Attachment files (PDFs, PPTXs, DOCXs)
- Transcript artifacts (JSON, TXT)
- Annotations (JSON with tags and notes)
- AI notes (Markdown + metadata JSON)
- Extracted text indices (from PDFs/PPTXs)
- Cached retrieval chunks (JSON)
- Exports (ZIP files, temporary)
- Work directories (temporary transcoding files)

**Why Filesystem?**
- Audio/attachment files are binary and large (not suitable for SQLite)
- Transcript processing creates intermediate files (chunks, work directories)
- File serving is efficient via `send_file()`
- Persistence across server restarts is automatic

**What Lives in SQLite?**
- Module/session records (identity + metadata)
- AI chat history (messages + references to sources)
- Job status (for polling)
- Session/module summaries (for caching)

---

## Part 2: Deterministic Folder Structure

### Directory Hierarchy

```
DATA_DIR (studyscribe/data/)
└── modules/
    └── <module_id>/                          [UUID]
        ├── sessions/
        │   └── <session_id>/                 [UUID]
        │       ├── audio/
        │       │   ├── lecture.mp3
        │       │   ├── lecture.wav            (may be converted from mp3)
        │       │   └── ...
        │       ├── attachments/
        │       │   ├── slides.pdf
        │       │   ├── notes.docx
        │       │   ├── extracted.txt          (combined extracted text)
        │       │   ├── extracted_sources.json (structured source metadata)
        │       │   └── ...
        │       ├── transcript/
        │       │   ├── transcript.json        (segments with start/end/text)
        │       │   ├── transcript.txt         (human-readable)
        │       │   ├── transcript.srt         (SubRip format, if available)
        │       │   └── chunks.json            (retrieval chunks for Q&A)
        │       ├── work/                      (temporary, may be cleaned up)
        │       │   ├── chunks/
        │       │   │   ├── chunk_000.wav
        │       │   │   ├── chunk_001.wav
        │       │   │   └── ...
        │       │   └── lecture.wav            (converted from original)
        │       ├── notes/
        │       │   ├── ai_notes.md            (generated by Gemini)
        │       │   ├── ai_notes.json          (summary + suggested_tags)
        │       │   └── last_answer.json       (last Q&A answer + sources)
        │       ├── annotations.json           (user notes + tags)
        │       ├── exports/
        │       │   └── StudyScribe_Module_Session_20240115-103045.zip
        │       └── (deleted when session is deleted)
```

### Folder Helper Functions

**Module Directory** [studyscribe/app.py](studyscribe/app.py#L156-L158):
```python
def _module_dir(module_id: str) -> Path:
    return DATA_DIR / "modules" / module_id
```

**Session Directory** [studyscribe/app.py](studyscribe/app.py#L162-L165):
```python
def _session_dir(module_id: str, session_id: str) -> Path:
    return _module_dir(module_id) / "sessions" / session_id
```

### Subdirectory Purposes

#### audio/
- **Purpose**: Stores user-uploaded audio files for transcription
- **Contents**: Original upload format (MP3, WAV, M4A, etc.) + optional WAV conversion
- **Allowed Extensions** [studyscribe/app.py](studyscribe/app.py#L343): `.wav`, `.mp3`, `.m4a`, `.aac`, `.flac`, `.ogg`
- **Lifecycle**: 
  - Created: On first audio upload [studyscribe/app.py](studyscribe/app.py#L876-L905)
  - Modified: Deleted and recreated if user selects "replace" [studyscribe/app.py](studyscribe/app.py#L896-L901)
  - Deleted: When session is deleted [studyscribe/app.py](studyscribe/app.py#L2020-L2035)
- **Export**: Included if user checks `include_audio` in export modal

#### attachments/
- **Purpose**: Stores document/slide uploads (PDFs, PowerPoint, Word)
- **Contents**: Original files + extracted text index
- **Allowed Extensions** [studyscribe/app.py](studyscribe/app.py#L344): `.pdf`, `.ppt`, `.pptx`, `.doc`, `.docx`
- **Automatic Indexing** [studyscribe/app.py](studyscribe/app.py#L453-L490): 
  - `extracted.txt`: Combined extracted text from all attachments
  - `extracted_sources.json`: Structured metadata (see "Attachment Sources" below)
- **Lifecycle**:
  - Created: On first attachment upload [studyscribe/app.py](studyscribe/app.py#L906-L942)
  - Modified: Rebuilt when new attachment added [studyscribe/app.py](studyscribe/app.py#L920-L922)
  - Indexed: Automatically via `_rebuild_attachment_index()` [studyscribe/app.py](studyscribe/app.py#L453-L490)
- **Export**: Included if user checks `include_attachments` in export modal

#### transcript/
- **Purpose**: Stores Whisper transcription output and cached chunks
- **Contents** [studyscribe/services/transcribe.py](studyscribe/services/transcribe.py#L100-L128):
  - `transcript.json`: Segment array `[{start, end, text}, ...]`
  - `transcript.txt`: Human-readable format `[00:00-00:05] Hello everyone...`
  - `chunks.json`: Retrieval chunks for Q&A (built via [studyscribe/services/retrieval.py](studyscribe/services/retrieval.py))
- **Lifecycle**:
  - Created: When user clicks "Transcribe" [studyscribe/app.py](studyscribe/app.py#L1139-L1151)
  - Deleted: When user clicks "Delete Transcript" or replaces audio [studyscribe/app.py](studyscribe/app.py#L1071-L1087), [studyscribe/app.py](studyscribe/app.py#L206-L221)
  - Cleared: Transcript deleted but annotations preserved [studyscribe/app.py](studyscribe/app.py#L206-L221)
- **Export**: Included if user checks `include_transcript` in export modal
- **Optional**: Raw chunks included only if `include_raw_chunks=1` in advanced export options

#### notes/
- **Purpose**: Stores AI-generated notes and Q&A artifacts
- **Contents**:
  - `ai_notes.md`: Markdown output from Gemini `generate_notes()` [studyscribe/services/gemini.py](studyscribe/services/gemini.py)
  - `ai_notes.json`: Metadata `{summary, suggested_tags}`
  - `last_answer.json`: Last Q&A response `{answer, answer_markdown, sources, context_sources, scope, question}` [studyscribe/app.py](studyscribe/app.py#L1560-L1565)
- **Lifecycle**:
  - Created: When user clicks "Generate Notes" [studyscribe/app.py](studyscribe/app.py#L1199-L1262)
  - Persisted: Via background job completion
  - Deleted: When session is deleted [studyscribe/app.py](studyscribe/app.py#L2020-L2035)
- **Export**: `ai_notes.md` included if user checks `include_ai_notes`; Q&A not exported by default

#### annotations.json
- **Purpose**: Stores user-created tags, personal notes, and session metadata
- **Schema** [studyscribe/app.py](studyscribe/app.py#L1162-L1197):
  ```json
  {
    "tags": {
      "seg_0": ["IMPORTANT"],
      "seg_1": ["CONFUSING", "EXAM-SIGNAL"]
    },
    "notes": "Plain text notes",
    "notes_html": "<div>HTML formatted notes</div>",
    "notes_markdown": "# Markdown formatted notes\n...",
    "session_tags": ["Chemistry", "Organic"]
  }
  ```
- **Lifecycle**:
  - Created: First time user saves notes [studyscribe/app.py](studyscribe/app.py#L1162-L1197)
  - Modified: Each time user updates tags, notes, or session tags
  - Cleared/Modified: When transcript is deleted [studyscribe/app.py](studyscribe/app.py#L206-L221) (clears transcript-related tags only)
- **Export**: Personal notes included if user checks `include_personal_notes`

#### work/
- **Purpose**: Temporary directory for transcoding and chunk processing
- **Contents**:
  - `chunks/`: WAV chunks split from audio for transcription
  - `*.wav`: Converted audio file (if original is not WAV)
- **Lifecycle**:
  - Created: During transcription job [studyscribe/services/transcribe.py](studyscribe/services/transcribe.py#L73-L130)
  - Not cleaned up: Remains after transcription completes (safe to delete manually)
- **Export**: Never exported

#### exports/
- **Purpose**: Stores generated ZIP export files
- **Contents**: ZIP files named `StudyScribe_{module_name}_{session_name}_{timestamp}.zip`
- **Lifecycle**:
  - Created: When user submits export form [studyscribe/app.py](studyscribe/app.py#L2036-2100)
  - Served: Via `send_file()` as download [studyscribe/app.py](studyscribe/app.py#L2098-L2100)
  - Not cleaned up: Remains indefinitely (safe to delete)
- **Export**: Never included in exports

---

## Part 3: Naming Rules & Sanitization

### Module/Session Names

**User Input**: Provided by user when creating module or session [studyscribe/app.py](studyscribe/app.py#L726-L737), [studyscribe/app.py](studyscribe/app.py#L748-L759)

**Sanitization Function** [studyscribe/app.py](studyscribe/app.py#L704-L709):
```python
def _safe_filename_component(value: Optional[str], fallback: str) -> str:
    """Normalize user-provided strings into filename-safe components."""
    raw = (value or "").strip() or fallback
    safe = re.sub(r"[^A-Za-z0-9._-]+", "_", raw).strip("._")
    return safe or fallback
```

**Rules**:
1. Allowed characters: `A-Z`, `a-z`, `0-9`, `.`, `_`, `-`
2. All other characters → replaced with `_`
3. Leading/trailing `.` and `_` → stripped
4. Empty result → falls back to provided `fallback` (UUID)
5. Examples:
   - `"Organic Chemistry"` → `"Organic_Chemistry"`
   - `"Lecture 1: Intro"` → `"Lecture_1__Intro"`
   - `"課程" (Chinese)` → `"___"`
   - `""` (empty) → falls back to UUID

**Where Used**: 
- Export ZIP filenames [studyscribe/app.py](studyscribe/app.py#L2076-L2079)
- NOT used for database storage (names stored as-is in `modules.name`, `sessions.name`)
- NOT used for folder names (UUIDs used instead for uniqueness)

### Audio Filenames

**Original**: Preserved as-is from upload [studyscribe/services/audio.py](studyscribe/services/audio.py)

**Conversion**: If MP3/M4A/etc. uploaded, converted to WAV and stored alongside original [studyscribe/services/transcribe.py](studyscribe/services/transcribe.py#L24-L38)

### Attachment Filenames

**Original**: Preserved as-is from upload [studyscribe/app.py](studyscribe/app.py#L906-L942)

**Constraints**: Must match `ALLOWED_ATTACHMENT_EXTENSIONS` and `ALLOWED_ATTACHMENT_MIME_TYPES` [studyscribe/app.py](studyscribe/app.py#L344-L351)

### Special Files

**extracted.txt**: Fixed name, always `attachments/extracted.txt` [studyscribe/app.py](studyscribe/app.py#L478-L482)

**extracted_sources.json**: Fixed name, always `attachments/extracted_sources.json` [studyscribe/app.py](studyscribe/app.py#L483-L487)

**annotations.json**: Fixed name, always in session root [studyscribe/app.py](studyscribe/app.py#L1195)

**Transcript Files**: Fixed names [studyscribe/services/transcribe.py](studyscribe/services/transcribe.py#L119-L128):
- `transcript/transcript.json`
- `transcript/transcript.txt`
- `transcript/chunks.json`

**AI Notes**: Fixed names [studyscribe/app.py](studyscribe/app.py#L1242-L1245):
- `notes/ai_notes.md`
- `notes/ai_notes.json`
- `notes/last_answer.json`

---

## Part 4: Export Flow Contract

### Export Modal & UI

**UI Location**: [studyscribe/web/templates/session.html](studyscribe/web/templates/session.html#L365-L430)

**Trigger**: "Export" button in session header [studyscribe/web/templates/session.html](studyscribe/web/templates/session.html#L64)

**Modal Layout**:
```html
<form id="exportForm" method="post" action="/modules/{module_id}/sessions/{session_id}/export" data-export-form>
  <div class="exportOptions">
    <label><input name="include_ai_notes" value="1" checked /></label>
    <label><input name="include_personal_notes" value="1" checked /></label>
    <label><input name="include_transcript" value="1" checked /></label>
    <label><input name="include_audio" value="1" checked /></label>
    <label><input name="include_attachments" value="1" checked /></label>
  </div>
  
  <details class="exportAdvanced">
    <summary>Advanced</summary>
    <label><input name="include_raw_chunks" value="1" /></label>
    <label><input name="include_prompt_manifest" value="1" /></label>
  </details>
  
  <button type="submit">Export</button>
</form>
```

**Checkbox Defaults**: All main options checked (`include_ai_notes`, `include_personal_notes`, `include_transcript`, `include_audio`, `include_attachments`)

**Advanced Options** (unchecked by default):
- `include_raw_chunks`: Includes `transcript/chunks.json` for debugging/rebuilding retrieval
- `include_prompt_manifest`: Includes `prompt_manifest.json` with Gemini prompt inputs/outputs for reproducibility

### Export Endpoint

**Route** [studyscribe/app.py](studyscribe/app.py#L2036):
```
POST /modules/<module_id>/sessions/<session_id>/export
```

**Handler** [studyscribe/app.py](studyscribe/app.py#L2036-L2100):
```python
def export_pack(module_id: str, session_id: str):
    """Export a session pack based on user selections."""
```

**Request Method**: POST

**Request Body** (form-data):
```
include_ai_notes=1
include_personal_notes=1
include_transcript=1
include_audio=1
include_attachments=1
include_raw_chunks=0
include_prompt_manifest=0
```

**Note**: Checkboxes only appear in form data if checked (standard HTML form behavior). Unchecked boxes send nothing, so handler defaults to `False` for `include_raw_chunks` and `include_prompt_manifest`.

**Response**:
- **Content-Type**: `application/zip`
- **Content-Disposition**: `attachment; filename="StudyScribe_ModuleName_SessionName_20240115-103045.zip"`
- **Body**: Binary ZIP file

**Error Responses**:
- **404**: Session or module not found → `{"ok": false, "error": "Session not found."}`
- **400**: No options selected → `{"ok": false, "error": "Select at least one item to export."}`
- **500**: Export build failed → `{"ok": false, "error": "Export failed. Please try again."}`

### Export Implementation

**Builder Function** [studyscribe/services/export.py](studyscribe/services/export.py#L246-L314):
```python
def build_session_export(
    session_dir: Path,
    output_path: Path,
    module_name: str,
    session_name: str,
    selections: dict[str, bool],
    *,
    include_raw_chunks: bool = False,
    include_prompt_manifest: bool = False,
    module_id: Optional[str] = None,
    session_id: Optional[str] = None,
) -> Path:
```

---

## Part 5: Export ZIP Structure & Manifest

### ZIP Folder Layout

```
StudyScribe/
└── {safe_module_name}/
    └── {safe_session_name}/
        ├── ai_notes.md
        ├── personal_notes.html
        ├── personal_notes.md
        ├── transcript.txt
        ├── audio/
        │   ├── lecture.mp3
        │   └── ...
        ├── attachments/
        │   ├── slides.pdf
        │   ├── notes.docx
        │   └── ...
        ├── raw/
        │   └── chunks.json
        ├── prompt_manifest.json
        └── manifest.json
```

**Root Path Template** [studyscribe/services/export.py](studyscribe/services/export.py#L271-L275):
```python
safe_module = _safe_name(module_name, "Module")
safe_session = _safe_name(session_name, "Session")
root = f"StudyScribe/{safe_module}/{safe_session}"
```

**_safe_name()** [studyscribe/services/export.py](studyscribe/services/export.py#L25-L31):
```python
def _safe_name(value: Optional[str], fallback: str) -> str:
    """Sanitize user-provided names for zip paths."""
    raw = (value or "").strip()
    if not raw:
        raw = fallback
    safe = raw.replace("/", "_").replace("\\", "_").strip()
    return safe or fallback
```

### Manifest JSON

**File**: `manifest.json` (always included, root of ZIP)

**Schema** [studyscribe/services/export.py](studyscribe/services/export.py#L303-L313):
```json
{
  "module": {
    "id": "57819ed8-f56c-424a-97a6-6d0383493fa2",
    "name": "Organic Chemistry"
  },
  "session": {
    "id": "c26ed045-9b3b-47a7-b430-d3e2b5476d52",
    "name": "Lecture 1: Introduction"
  },
  "exported_at": "2024-01-15T10:30:45+00:00",
  "included": {
    "include_ai_notes": true,
    "include_personal_notes": true,
    "include_transcript": true,
    "include_audio": true,
    "include_attachments": true,
    "include_raw_chunks": false,
    "include_prompt_manifest": false
  },
  "files": [
    "StudyScribe/Organic_Chemistry/Lecture_1__Introduction/ai_notes.md",
    "StudyScribe/Organic_Chemistry/Lecture_1__Introduction/personal_notes.md",
    "StudyScribe/Organic_Chemistry/Lecture_1__Introduction/transcript.txt",
    "StudyScribe/Organic_Chemistry/Lecture_1__Introduction/audio/lecture.mp3",
    "StudyScribe/Organic_Chemistry/Lecture_1__Introduction/manifest.json"
  ]
}
```

**Fields**:
- `module.id`, `module.name`: Module UUID and user-provided name
- `session.id`, `session.name`: Session UUID and user-provided name
- `exported_at`: ISO 8601 UTC timestamp of export generation
- `included`: Object matching the export form selections (all boolean flags)
- `files`: Array of all files included in ZIP (sorted), absolute paths from ZIP root

### Prompt Manifest (Advanced Option)

**File**: `prompt_manifest.json` (only if `include_prompt_manifest=1`)

**Purpose**: Reproducibility/debugging aid; contains Gemini API inputs/outputs

**Schema** [studyscribe/services/export.py](studyscribe/services/export.py#L236-L245):
```json
{
  "exported_at": "2024-01-15T10:30:45+00:00",
  "meta": {
    "module": {
      "id": "57819ed8-f56c-424a-97a6-6d0383493fa2",
      "name": "Organic Chemistry"
    },
    "session": {
      "id": "c26ed045-9b3b-47a7-b430-d3e2b5476d52",
      "name": "Lecture 1"
    },
    "included": {
      ...all export selections...
    }
  },
  "ai_notes": {
    "summary": "This lecture covers...",
    "citations": [...]  // if available
  },
  "last_answer": {
    ...full Q&A response object from last_answer.json...
  }
}
```

**Contents**:
- `ai_notes.summary`: First line of `ai_notes.json` (summary field)
- `ai_notes.citations`: Citation references from Q&A (if any Q&A was performed)
- `last_answer`: Full JSON from `session_dir/notes/last_answer.json`, including:
  - `question`: User's last question
  - `answer`: Gemini's response
  - `answer_markdown`: With citation markers
  - `sources`: Structured source array with locators
  - `context_sources`: Summary of context used
  - `scope`: "session" or "module"

### Raw Chunks (Advanced Option)

**File**: `raw/chunks.json` (only if `include_raw_chunks=1`)

**Purpose**: Debugging/analysis of retrieval system; shows exact chunks used for Q&A

**Schema** (from [studyscribe/services/retrieval.py](studyscribe/services/retrieval.py)):
```json
[
  {
    "id": "chunk_0",
    "text": "The mechanism of oxidation involves electron transfer...",
    "start": 12.5,
    "end": 47.2,
    "session_id": "c26ed045-...",
    "session_name": "Lecture 1",
    "kind": "transcript"
  },
  {
    "id": "chunk_1",
    "text": "Oxidation state is the number of electrons...",
    "start": 0.0,
    "end": 0.0,
    "session_id": "c26ed045-...",
    "session_name": "Lecture 1",
    "kind": "attachment",
    "filename": "slides.pdf",
    "page": 3,
    "mime": "application/pdf"
  }
]
```

**Chunk Types** (from [studyscribe/app.py](studyscribe/app.py#L1350-L1430)):
- `transcript`: Segments from audio transcription with start/end times
- `attachment`: Extracted text from PDFs/PPTXs with page/slide metadata
- `ai_notes`: Chunks from AI-generated notes with anchor heading
- `notes`: Chunks from personal annotations
- `cache`: Cached session/module summaries (filtered out in Q&A, not exported by default)

### Included Files by Selection

**include_ai_notes=1**:
- Copies `notes/ai_notes.md` → `{root}/ai_notes.md`

**include_personal_notes=1**:
- Copies `annotations.json` → `{root}/personal_notes.html` (if notes_html exists)
- Copies `annotations.json` → `{root}/personal_notes.md` (if notes_markdown exists)
- Falls back to plain text conversion if only plain notes exist

**include_transcript=1**:
- Copies `transcript/transcript.txt` → `{root}/transcript.txt` (or SRT if TXT missing)

**include_audio=1**:
- Copies all files from `audio/` → `{root}/audio/` (preserves original filenames)
- Allowed extensions [studyscribe/services/export.py](studyscribe/services/export.py#L14): `.wav`, `.mp3`, `.m4a`, `.aac`, `.flac`, `.ogg`

**include_attachments=1**:
- Copies all files from `attachments/` → `{root}/attachments/` (skips `extracted.txt` and `extracted_sources.json`)
- Allowed extensions [studyscribe/services/export.py](studyscribe/services/export.py#L15): `.pdf`, `.ppt`, `.pptx`, `.doc`, `.docx`

**include_raw_chunks=1**:
- Copies `transcript/chunks.json` → `{root}/raw/chunks.json`
- Only if `transcript/chunks.json` exists

**include_prompt_manifest=1**:
- Generates and writes `prompt_manifest.json` → `{root}/prompt_manifest.json`

---

## Part 6: Export Implementation Details

### Validation & Defaults

**Handler Entry** [studyscribe/app.py](studyscribe/app.py#L2036-L2063):
1. Loads session and module records
2. Defaults all selections to `True` (all items included by default on GET request)
3. On POST, reads form fields and overrides defaults

**Validation**:
- Session/module must exist (404 if not) [studyscribe/app.py](studyscribe/app.py#L2047-L2051)
- At least one selection must be checked (400 if all unchecked) [studyscribe/app.py](studyscribe/app.py#L2093-L2098)

### ZIP Creation

**Library**: Python `zipfile.ZipFile` with `ZIP_DEFLATED` compression [studyscribe/services/export.py](studyscribe/services/export.py#L270)

**Filename Template** [studyscribe/app.py](studyscribe/app.py#L2076-L2079):
```python
timestamp = datetime.now(timezone.utc).strftime("%Y%m%d-%H%M%S")
safe_module = _safe_filename_component(module["name"], module_id)
safe_session = _safe_filename_component(session["name"], session_id)
download_name = f"StudyScribe_{safe_module}_{safe_session}_{timestamp}.zip"
```

**Example**: `StudyScribe_Organic_Chemistry_Lecture_1_20240115-103045.zip`

**Output Location**: `session_dir/exports/{download_name}`

**File Addition Helper** [studyscribe/services/export.py](studyscribe/services/export.py#L282-L293):
```python
def add_path(zf: zipfile.ZipFile, path: Path, arcname: str) -> None:
    """Add file to ZIP if it exists."""
    if not path.exists():
        return
    zf.write(path, arcname=arcname)
    manifest_files.append(arcname)

def add_text(zf: zipfile.ZipFile, text: str, arcname: str) -> None:
    """Add text as file entry."""
    if not text.strip():
        return
    zf.writestr(arcname, text)
    manifest_files.append(arcname)
```

### File Serving

**Response** [studyscribe/app.py](studyscribe/app.py#L2098-L2100):
```python
response = send_file(output_path, as_attachment=True, download_name=download_name, mimetype="application/zip")
response.headers["Content-Disposition"] = f'attachment; filename="{download_name}"'
return response
```

**Effect**: Browser downloads file with name `StudyScribe_*.zip`

---

## Part 7: Filename Safety & Constraints

### Reserved Characters (Sanitized in Export)

**Function** [studyscribe/services/export.py](studyscribe/services/export.py#L25-L31):
```python
safe = raw.replace("/", "_").replace("\\", "_").strip()
```

**Rules**:
- Forward slash `/` → underscore `_` (prevents directory traversal)
- Backslash `\` → underscore `_` (prevents directory traversal on Windows)
- Leading/trailing spaces → stripped

### Comparison: _safe_filename_component vs _safe_name

| Function | Use Case | Allowed Characters | Restrictions |
|----------|----------|-------------------|---|
| `_safe_filename_component()` [studyscribe/app.py](studyscribe/app.py#L704) | Export ZIP filenames | `[A-Za-z0-9._-]` | Strips leading/trailing `.` and `_`, regex replacement |
| `_safe_name()` [studyscribe/services/export.py](studyscribe/services/export.py#L25) | ZIP folder paths | All except `/` and `\` | Simple character replacement |

**Example**:
- User enters: `"Lecture 1: Intro (Part A)"`
- _safe_filename_component: `"Lecture_1__Intro__Part_A"` (strict)
- _safe_name: `"Lecture 1: Intro (Part A)"` (permissive, used inside ZIP)

---

## Part 8: Deletion & Cleanup

### Session Deletion

**Handler** [studyscribe/app.py](studyscribe/app.py#L2020-L2035):
```python
def delete_session(session_id: str):
    session = fetch_one("SELECT * FROM sessions WHERE id = ?", (session_id,))
    if not session:
        return jsonify({"error": "Session not found."}), 404
    module_id = session["module_id"]
    _delete_path(_session_dir(module_id, session_id))  # Deletes entire folder
    execute("DELETE FROM sessions WHERE id = ?", (session_id,))
    ...
```

**Side Effects**:
- Deletes entire directory: `DATA_DIR/modules/{module_id}/sessions/{session_id}/`
- Includes: audio, attachments, transcript, notes, annotations, work, exports
- DB row deleted: `sessions` table entry removed
- Related DB rows may be deleted: `ai_messages` and `ai_message_sources` (if foreign key cascade configured)

### Module Deletion

**Handler** [studyscribe/app.py](studyscribe/app.py#L1994-L2007):
```python
def delete_module(module_id: str):
    sessions = fetch_all("SELECT id FROM sessions WHERE module_id = ?", (module_id,))
    for session in sessions:
        _delete_path(_session_dir(module_id, session["id"]))
    execute("DELETE FROM sessions WHERE module_id = ?", (module_id,))
    execute("DELETE FROM modules WHERE id = ?", (module_id,))
    _delete_path(_module_dir(module_id))
    ...
```

**Side Effects**:
- Deletes all sessions' folders first
- Deletes module folder: `DATA_DIR/modules/{module_id}/`
- DB rows deleted: all sessions + module itself

### Transcript Deletion

**Handler** [studyscribe/app.py](studyscribe/app.py#L1071-L1087):
```python
def delete_transcript(module_id: str, session_id: str):
    session_dir = _session_dir(module_id, session_id)
    transcript_dir = session_dir / "transcript"
    _delete_path(transcript_dir)
    _clear_transcript(session_dir)  # Also clears transcript-related tags
```

**Side Effects**:
- Deletes `transcript/` directory and all contents
- Clears segment tags from `annotations.json` (preserves personal notes)
- Session tags not affected

---

## Summary Table: Data Lifecycle

| Data Type | Stored In | Created On | Modified On | Deleted On | Exported |
|-----------|-----------|-----------|-----------|-----------|----------|
| Module record | SQLite | Create module | Rename module | Delete module | manifest.json |
| Session record | SQLite | Create session | Rename session | Delete session | manifest.json |
| Audio file | FS: `audio/` | Upload audio | Replace audio | Delete audio/session | Yes (`include_audio`) |
| Attachment file | FS: `attachments/` | Upload attachment | - | Delete attachment/session | Yes (`include_attachments`) |
| extracted.txt | FS: `attachments/` | Upload attachment | Rebuild on upload | Delete attachment/session | No |
| extracted_sources.json | FS: `attachments/` | Upload attachment | Rebuild on upload | Delete attachment/session | No |
| Transcript JSON | FS: `transcript/` | Transcribe audio | - | Delete transcript/session | No (text exported) |
| Transcript TXT | FS: `transcript/` | Transcribe audio | - | Delete transcript/session | Yes (`include_transcript`) |
| Chunks JSON | FS: `transcript/` | Transcribe audio | - | Delete transcript/session | Only if `include_raw_chunks` |
| Annotations JSON | FS: `annotations.json` | Save notes/tags | Save notes/tags | Delete session/transcript | Notes via export |
| AI notes MD | FS: `notes/` | Generate notes | - | Delete session | Yes (`include_ai_notes`) |
| AI notes JSON | FS: `notes/` | Generate notes | - | Delete session | Only in manifest |
| Last answer JSON | FS: `notes/` | Ask question | Update on new Q&A | Delete session | Only if `include_prompt_manifest` |
| AI messages | SQLite | Ask question | - | Delete session (cascade) | Yes (in manifest) |
| AI sources | SQLite | Ask question | - | Delete session (cascade) | Yes (in manifest) |
| Export ZIP | FS: `exports/` | POST export | - | Manual cleanup | No |

---

## Implementation Checklist

- [x] SQLite schema covers modules, sessions, jobs, AI messages/sources
- [x] Deterministic paths use UUIDs (not user names) to prevent collisions
- [x] All user inputs sanitized before filesystem use
- [x] Export modal provides form with checkboxes + advanced options
- [x] Export endpoint validates selections and builds ZIP
- [x] Manifest JSON documents export metadata and file listing
- [x] Prompt manifest option for reproducibility
- [x] Raw chunks option for debugging retrieval
- [x] Deletion cascades: session delete removes all files, module delete removes all sessions
- [x] File lifecycle documented with creation/modification/deletion triggers

---

*Last Updated: 2024-01-15*  
*Evidence: [studyscribe/core/db.py](studyscribe/core/db.py), [studyscribe/core/config.py](studyscribe/core/config.py), [studyscribe/app.py](studyscribe/app.py), [studyscribe/services/export.py](studyscribe/services/export.py), [studyscribe/services/transcribe.py](studyscribe/services/transcribe.py), [studyscribe/web/templates/session.html](studyscribe/web/templates/session.html)*
